２、マルチクライアント select
クライアントからの接続ソケット生成
-- loop
配列に入っているディスクリプタをselectの監視下にする。
クライアントからの接続ソケットをselectの監視下に入れる。
selectで監視する。
クライアントからの接続があれば、acceptしてその接続ソケットを配列に格納する。
select監視対象のソケットがレディーであるかをチェックする（配列をチェック）
レディーであるソケットに対して、sendとrecvを行う。
-- end

３、マルチクライアント poll
selectをpollに変えた

４、マルチクライアント epoll
クライアントからの接続ソケット生成
クライアントからの接続ソケットをepollの監視下に入れる。
-- loop
selectで監視する。
レディーであるソケットだけが構造体配列に入ってる。
クライアントからの接続かacceptの接続ソケットかで処理を分ける。
クライアントからの接続の場合はacceptしてその接続ソケットをepollの監視下に入れる。
acceptの接続ソケットの場合はsendとrecvを行う。
-- end

５、マルチプロセスによる多重化
クライアントからの接続ソケット生成
-- loop
acceptでクライアントからの接続を受け付ける。
forkして子プロセスでsend、recvを行う。
-- end

６、マルチスレッドによる多重化
クライアントからの接続ソケット生成
-- loop
acceptでクライアントからの接続を受け付ける。
pthreadしてthreadでsend、recvを行う。
-- end

７、マルチプロセスによる多重化（接続受付も）
クライアントからの接続ソケット生成（多重化）
 ->prepork（あらかじめ決まった個数の接続受付を生成しておく）
-- loop
acceptは各プロセスで排他になるようにlockする
各子プロセスでクライアントからの接続があれば、send、recvを行う。
-- end

８、マルチスレッドによる多重化（接続受付も）
クライアントからの接続ソケット生成
pthreadしてthreadで接続受付（accept）を行う（多重化）
 ->prethread（あらかじめ決まった個数の接続受付を生成しておく）
-- loop
acceptは各threadで排他になるようにlockする
各子プロセスでクライアントからの接続があれば、send、recvを行う。
-- end

９、
pthreadでthreadでキュー処理を行う
-- loop
lock
格スレッドで
 受信キューを待つ。（wait）
 offsetを１つ進める。
unlock
 受信キューがあれば（signalで起こされる）デキュー（offset-1のキュー）して送信。
-- end

クライアントからの接続ソケットをepollの監視下に入れる。
-- loop
selectで監視する。
レディーであるソケットだけが構造体配列に入ってる。
クライアントからの接続かacceptの接続ソケットかで処理を分ける。
クライアントからの接続の場合はacceptしてその接続ソケットをepollの監視下に入れる。
acceptの接続ソケットの場合はrecvを行う。
lock
エンキューする。
キューのoffsetを１つ進める
signalを送る（起こす）
unlock
-- end

 



